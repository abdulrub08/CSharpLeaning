





1) Platform Independent :

case 1

obs 1 : as .class file is executable in any OS with the help of JVM( Java Virtual
 Machine ), hence Java is called as platform independent.

JVM Software is platform dependent.
a seperate version of JVM software is introduced for every OS.

case 2

obs 2 : as .exe (executable) or .DLL (Dynamic Link Library) are executable in any OS
 with the help of a CLR (Common Language Runtime).

hence .Net is platform independent.
for every OS a seperate version of CLR is available, hence CLR is Platform
 dependent.

********* is .Net is Pure Platform Independent or not ?

.Net is partially Platform Independent Languages.
as of now CLR softwares are not yet developed for DOS and Win 95





2) Language Independent :






D


as .Net application logic can be developed in any .net framework compatiable
 languages,hence .Net is called as Language Independent.

as of now .net framework is supporting.



11 languages + 1 specification ( ASP.Net )

1) Visual C#.Net
2) Visual Basic.Net
3) Visual J#.Net
4) Visual C++.Net
5) COBOL.Net
6) PERL.Net
7) VBScript.Net
8) JScript.Net
9) PHP.Net
10) Small Talk.Net
11) Python.Net


VB.Net is not case sensitive
C#.Net is case sensitive
ASP.Net is depend on Language


ASP.Net is a specification, which provides a set of rules and these rules
 need to be followed by Integrated Language.










What is DLL?
as per VB6.0 or VC++6.0

DLL = Reusable = COM = OS dependent = Platform dependent


1) as per VB6.0 or VC++6.0, DLLs are called as COM Components.
2) COM is used to developed Reusable Components.
3) COM Components must be registered for a class id.
4) Class ID is part of Registry.
5) as Registry is u/c of Windows OS, hence COM is Platform dependent.


What is DLL as per .Net?

1) as per .Net, A DLL contains platform independent code in the format of
 Byte Code.
2) A DLL is also called as Assembly.
3) A DLL is also called as Managed Code.
4) A DLL is also called as MSIL.



What is managed code?

> The Code, which targets CLR is called as Managed Code.
> The Code, which takes OS help while execution is called as UNManaged Code.
> Managed Code is faster in Execution.


.Net framework is intoduced as a development platform.

as Memory Management is u/c of .Net framework with the help of Garbage Collector
 ( GC ).hence .Net framework is called as development.








.Net framework is devided into Two Parts
  
1) FCL ( Framework Class Library )
2) CLR ( Common Language Runtime )


#include<stdio.h>        = Header file = Collection of Methods
main()
{
	printf("hello");
}


> FCL is a collection of predefined classes, which are distributed as Assembilies.
> A collection of classes is called as a Namespace.
> A Collection of Namespaces is called as an Assembly.
> A collection of Assembilies is called as FCL.

FCL Contains :
> 6000 predefined classes.
> 65000 predefined methods.
> 1,00,000 predefined properties.



What is CLR ?

CLR is a standard runtime execution engine for Managed Code.

when .net is installed, then CLR related files will be stored in
C:\Windows\System32  folder

> The most important file in CLR software is MSCoreE.DLL (Microsoft
 Core Execution Library)



Version of .Net

> .Net framework version = 3.5
> .Net IDE Version = 2008
> C#.Net Lang version = 2008 or 3.0
> CLR version = 2.0.50727.1433












3) Language Integration :

Language Integration is a concept of developing an application with the help
 of more than one .Net compatiable languages.

Assembly is a collection of classes developed in different languages and
 packed as a DLL to achieve  a task.

After a project is executed, then CLS (Common Language Specification)
 format will be created.

CLS contains the Common Syntaxes for all the Languages.

CLS contains the Common datatypes for all the Languages, which are
 called as CTS (Common Type System)















obs: 

C#.Net			VB.Net				C++

short =2                short =2			int =2
int =4			int =4				long=4
long=8			long=8



			CTS Datatypes

			system.int16
			system.int32
			system.int64


Visual C#.Net 2008

Software Requirements
1) Windows XP, 2000 Prof., 2000 Server, Vista, 7
2) IIS Server
3) Visual Studio .Net 2008 Professional Edition
4) MS-Office
5) Sql Server or Oracle



OS		Service Pack

Win2000			4	
WinXP			2	
Win2003			2
WinVista		-

[Home editions also support C#.Net desktop applications]

	







Executable File :

In C lang.			In .Net lang.

first.c				first.cs

Compile				Compile

tcc first.c			csc first.cs

first.exe 			first.exe




**
These files have a capability for executing itself i.e, an OS doesn't have
 to depend upon any external tools or runtime for execution.



		Metadata

		Machine dependent code

		X86 Instruction set







Code : 

The code present within the executable file will be in the format of
 Machine Dependent.



X86 Instruction set :

It maintains the platform details which are needed for the execution.




Obs:
> Executable file maintains the complete information which is needed to
 execute any particular application.
> In C programming may or may not work in other enviornment.







Assembly :

The compiled source code of any .Net application is called as an Assembly.


Note :

> Assembly with as entry point, main method then they are called as
 Applications (.exe)
> Assembly without as entry point is called as Class Library (.dll)




.exe or .dll
	
		Metadata
	
		MSIL
	
		Resource

		Manifest


> It is called as "PE WRAPPER".
> (Portable Executable WRAPPER)
> It is an .exe file, then "PE WRAPPER" is present to call CLR.



Metadata :

It maintains the info. about the header files that are used with in the 
application. We can identify where the header files are located.


MSIL code :

The code present within the Assembly will be in the format of MSIL
 instructions (byte Code), where the MSIL format is a machine independent
 and platform independent.

Resource :

It maintains the information about the external resources used within the application
 such as audio-video clips, icons, cursors, images etc.

Manifest :

It maintains the details about the attributes of an Assembly such as the
 product name, description, version etc.




******
> Assembly just specifies about itself but it will not provide any info.
 needed for execution. so, we depend on CLR.
> Hence OS cannot execute the assembly on its own.






.Net 3.5 framework :


	.Net 2.0
	    +
	CS, WPF, WF, WCF, Language Enhancements		=.Net 3.0
	    +
	WF-Integration-WCF, WPF-3D, LINQ, AJAX		=.Net 3.5
	    +
	ASP.Net MVC, Dynamic Data programming, ADO.Net services	=.Net 3.5 SP1



WCF (Windows Communication Foundation) :

It is an unified programming model for achieving SOA applications or services.


**
>WCF Service can interact with .Net appl., MSMQ(MS Messaging Queue), MOSS and any application.



WF (Windows Workflow Foundation) :

It is a set of activities or tools which are used for building a business
 process which maintains a proper hierarchy.

> Can also be used from Sharepoint applications or with in Biztalk Server
 or any MS related product.





	WF Business Process


Leave request =	TeamLead Approval
		
		Approve/Reject	- if rejected then Cancel WF
		      A
		HR Approval

		Approve/Reject	- if rejected then Cancel WF	
		


**
> For preparing business process, we take the support of WF.








WPF (Windows Presentation Foundation) :

It is a framework which is used for buiding rich interactive application [RIA],
 which uses media services, Transformations, Animations etc.


CS (Card Space) :
It is used to provide a high security for the applications using the Card system.





**
.Net 3.5 has been introduced with new language features support such as :

> Implicit Type Definition
> Automated Properties
> Object initializers
> Collection initializers
> Parallel Methods
> Extension Methods





LINQ (Language Integrated Query) :

> It is introduced in .Net 3.5
> It is a new framework for retrieving the info. from the objects, database,
 Sql Classes or XML documents.


**
> LINQ can also be used for preparing manipulations on the data.





AJAX (Asynchronous JavaScript and XML) :

> It is a framework which is used for developing next generation Web Applications
 using asynchronous programming model.








Types of Applications :

1> Console Application :
Whenever the user accepts the i/p from the console and projects the o/p on the
console, then such type of applications are called as console Appl.
	
	Where console is a device which has a capability to accept the
 information and also to display the information.

> All C lang. appl. are console application. There are no "UI".







ex1 > A program to print a Message.

Open Notepad and type the logic as follows and save it with name Test.cs


using System;  				
class Test
{
static void Main()
{
Console.Write("Hello");
}
}


Save it as "Test.cs"



Steps for compiling the program :

1) Open Visual Studio.net Command prompt 
(start > programs > MS Visual Studio 2008 > Visual studio tools > Visual studio 2008 Command Prompt)

D:\New>csc Test.cs

obs : Test.exe file created

D:\New>csc Test.exe

obs : 
using System;
using is a keyword, which imports the classes of system Namespace ( Collection Of classes )




Class Test
> Class is a keyword

Static void Main()
> static = keyword
> void = return type 
> Main = function Name




Always execution starts from Main()




Console.Write("Hello");
> Console = predefined class
> . = Member Access Operator
> Write = Method (function)
> Hello = String




ex 2 : Writing a program with .Net (Integrated development environment)

open .Net IDE
Start > Programs > MS Visual Studio 2008

		or

Start > Run > Devenv


File Menu > New > Project



D



obs : For every project a new folder will be created where the folder name will be same as
 project name.


Default folder Structure

D:\New\First\Bin\Debug\output files


In ASP.Net project file is not be created.


Open Program.cs file from project solution explorer


write the following code in side of Main()
{
Console.Write("Hello");
Console.Write(DateTime.Now);
Console.ReadKey();
}



Execute the Project (Press F5 or debug > Start debugging)




Working with DataTypes

Data Types specifies type of the Data and size of the Data.

C#.Net Datatypes are divided into two types.



	Value Types ( Stack Memo.)				Reference Types(Heap Memory)

1)Value types hold the data directly.		1)Reference types holds the address but NOT data
2)Value types doesn't contains default value.	2)Reference types holds the default value.
3)Value types will stored in STACK memory 	3)Reference types will be Run time and 
at Compile time.					stored in HEAP memory
4)Garbage Collector cannot access STACK memory.	4)Garbage Collector can access HEAP memory.
5)Ex. of Value types				5)Ex. of Reference Types
Predefined data types, Structures, Enumerators.	Classes, Objects, Arrays, Delegates, Interfaces.




Working with Pre-defined DataTypes

These datatypes are divided into 4 groups.

G1)Integral Data Types
byte	-	1 byte	-	0-255
sbyte	-	1 byte	-	-128 to +127
short	-	2 bytes	-	-32768 to +32767
ushort	-	2 bytes	-	0 to 65535


int	-	4 bytes	-	~ +- 214 Crores
uint	-	4 bytes	-	~ -+  429 Crores
long	-	8 bytes	-	+- 2(63)
ulong 	-	8 bytes	-	o to 2(64) -1



G2)Floating Related Data Types

float	-	4 bytes	-	+- 4.3*10(-31)

double	-	8 bytes -	+- 4.3*10(-63)

decimal -	16 bytes-	+- 4.3*10(-127)



G3)Character Related Data types

Char	-	2 bytes

String 	-	16 bytes..........4GB


Char > It holds unicode charactors, which are required in Globalization Applications.


G4)Ohter Data types

bool	-	1 byte	-	true/false

Date/Time-	12 bytes
1/1/0001 - 31/12/9999


Syntax to declare a variable.

<data type> variablename=value;


Obs:
int K=10;
int K5=90;
int 5K=90;	\\ 
int _a=20;
int *P=90;
int @a=90;
int if=90;	\\	












ex> Open Console Application Project
Code in Main()
{
	int i=90;	// value type
	Console.WriteLine(i);
	float x=5.6f;		// Convert into float
	Console.WriteLine(x);
	byte b1=10, b2=20;
	byte C=b1+b2;
	Console.WriteLine(C);
	Console.ReadKey();
}

Execute the Project (F5)


Obs:
1)Value types must be initialized before using.

2)Float x=5.6 gives an error.
CLR treats 5.6 (any decimal number) as double, hence while initializing
 floats f must be postfixed.
a value postfixed with f or F is called as float.
a value postfixed with d or D is called as double.
a value postfixed with m or M is called as decimal.

3)in C#, +Operator returns the result in the format of int,
 hence byte C=b1+b2 gives an error.







Working with Type Casting

Type Casting is a concept of converting one datatype into another datatype.

C#.Net supports two types of Type Casting.

	Implicit TC				Explicit TC
1-4					4-1
byte b=10;				int i=10;
int i=b;				byte b=i;
u/c of CLR				u/c of programmer

Conv. Lower > Higher			Higher > Lower



C#.Net supports 4 types of explicit Type casting

1) C++ style of Type casting
2) Converting
3) Parsing
4) Boxing and UnBoxing



Working with C++ Style of Type Casting
ex>
	int i=90;
	byte b=i; // wrong
	byte b=(byte)i; //right

Syntax:
	DataType1 V1=value;
	DataType2 V2=(DataType2)V1;


ex>
Open Console App. project
Code in Main()
{
	int i=150;
	byte Sal=i; // wrong 	
	byte sal=(byte)i;
	Console.WriteLine("Salary is" +Sal);
	Console.ReadKey();
}



Obs:
in C++ style of Type Casting, there is a possibility for losing the Data.



Working with Converting

1)Working with a Predefined class called as CONVERT is called as Converting.
2)A class contains a collection of methods (Functions).



methods of convert class >

 byte b= Convert.ToByte(x)  // x is variable
 char c= Convert.ToChar(x)
 string c= Convert.ToString(x)
 float c= Convert.ToFloat(x)
 double c= Convert.ToDouble(x)
 decimal c= Convert.ToDecimal(x)
 short c= Convert.Toint16(x)	//for short
 int c= Convert.Toint32(x)	//for integer
 long c= Convert.Toint64(x)	//for long








ex :>
Code in Main()

{
 for (int i=0;i<=255;i++)
 {
  char c=Convert.Tochar(i);
  Console.Write(c);
  Console.Readkey();
 }
}

press F5





Working with Parsing :>
 
1) C#.Net, all the datatypes are predefined structures.
2) Structure contains a collection of methods.
3) In c#, all the datatypes contains of methods.
 Parse()
 Tostring()
 Minvalue
 Maxvalue
4) Working with Parse() is called as Parsing.
5) Parse() is used to convert from Strings into any another datatype.

[ String -> int ]
[ Anyone -> String ]











ex :>
a prog. to print the limits of a datatype.

Code for Main()

{
 Console.WriteLine(int.Maxvalue);
 Console.WriteLine(int.Minvalue);
 Console.ReadKey();
}

Press F5



ex: >

Code for Main()

{
 Console.Wrie("Enter your salary");
 String sal=Console.ReadLine();
 Console.Write("Enter Increment");
 String inc=Console.ReadLine();
 Console.WriteLine("Total :" + sal + inc);

 int s=int.Parse(sal);
 int i=int.Parse(inc);
 int t=s+i;
 Console.WriteLine("Total :" + t);
 Console.Readkey();
}

Press F5


Note : 
* ReadLine return as string always.



obs :
1) '+' operator will be used to add the numbers and also to concanate the strings.
 10+10=20
 "10"+"10"=1010
 "10"+10=1010

2) console applications are not user friendly.
3) console applications contains only logic but not GUI.
4) console applications are especially required for character based OS like DOS, hence
 Windows forms applications are recommanded for GUI programming.






Boxing and UnBoxing :>
1) Converting value Types into reference types is called Boxing.
2) Converting Reference types into value types is called unboxing.















Working with Arrays :

1) Array is a group of same(homogenous) datatypes.
2) Array are of Type reference.
3) Array will be stored in HEAP memory and also contains some default value.
4) Array will be stored in continuous memory.
5) Array shares same Name with a different Index number, which always starts from Zero.
6) Array are the instances (object) of a predefined class called as System.Array
7) If Array name is x then x.Length() gives the size of an array.
8) x.Sort()  arranges the values in ascending order.
9) x.Reverse()
10) x.Indexof()  gives the index number of a value.
11) C#.Net supports 3 types arrays.

 a) One-Dimensional Array
 b) Multi-Dimensional Array
 c) Jaggad Array



syntax to create One-D array :>
 datatype[] var=new datatype[size];

Note :

 int[] x=new int[5];
above stmt creates 5 elements from x[0] to x[4];

syntax to intialize an Array
 int[] x=new int[]{5,6,7,8,9};

while initializing an array the size is not recommended.
 char[] x=new char[]{'a','b','c'};


Note :>
integral Array default value is Zero.
floating Array default value is Zero.
char Array default value is Nothing.
Datetime Array default value is 1/1/0001 12:00:00 AM
bool Array default value is False.








ex :>
A prog. to display array default values.

code for button1_click()
{
 int[] x=new int[2];
  for(int i=0;i<x.length;i++)
  {
   MessageBox.Show(x[i].Tostring());
  }
}





Working with Multi-D Arrays :>

1) Arranging a set of values in Rows and cols is called as Multi-D Array.
2) Size of the Multi-D array will be indicated as no. of rows x no. of cols.

obs:
 x.Length  gives total no. of elements
 x.GetLength(0)  gives no. of rows
 x.GetLength(1)  gives no. of cols



syntax to declare Multi-D array

1D: int[] x=new int[size];
2D: int[,] x=new int[5,5];
3D: int[,,] x=new int[2,2,2];


Note:
VB.Net supports upto 32 D where as there is no limit in C#.Net(depends on memory(RAM))

syntax to initialize 2D array :>
int[,] x=new int[,]
{
{5,6,7,8},
{1,4,2,3},
{3,8,7,2}
}




Working with Jagged Arrays :>
1) JA is a collection of Rows, where every row may contains discrete no. of elements.
2) JA saves memory.
3) JA are faster in accessing.
4) JA is also called as Dynamic Array.
5) JA is also called as Array of Arrays.



syntax to declare JA
 int[][] x=new int[rows][];
// no. of cols are not allowed.

 x[0]=new int[]{1,2,3,4,5};
 x[1]=new int[]{5,6};


















Working with Enumerators ( enum ) :>

Phy=76
Math=67
Eng=88


1) enum is a keyword.
2) enum is a collection of integral constraints, which will be identified with string constants.
3) Syntax to declare enum.
	enum <enum_name>
	{
	 stringConstant = value,
	 .........,
	 .........
	}
4) Enums must be declared in general decleration (GD) area only.

Note :
 if enum member is not initialized, then it will be initialized automatically with
 incremented value of previous member.
 if previous member is not existing the initialization starts from 0 onwards.





ex on Enum 
	





OOPs Concepts (Object Oriented Programming Synopsis):>

OOPs based on the style of programming, the languages are divided into 3 types.

Procedural	Structured	OOPL
1960's ALGOL	1970's		1980's
No loops	BASIC		OOPs
No Arrays	COBOL		C++
No DMA		C



Problems with C lang. :>
1) 
 main()
 {
 int sal=40000;
 printf("%d",sal);
 }

output is ~ -7700
> There are no limits for the datatypes at runtime.



2) 
 main()
 {
 int i;
 i=500*500/500;
 printf("%d",i);
 }

output is -27
> There is no proper internal procedure for calculations.



3) 
 long sal=5000;
 main(){logic;}
 void Print(){logic;}
 void read(){logic;}
 void mktg()
 {
 long sal=500000;
 sal=sal+sal;
 }

No security for the data due to global variables.


> To overcome all these problems, ANSI defined a set of rules called as OOPs.
> When a lang. supports, the following OOPs concepts, then it is called as OOPL.

ex> C++, C#.Net, SmalkTalk, Java, VC++





OOPs concepts
			C++	VB6.0	Java/C#.Net
1) Encapsulation	Y	Y	Y
2) Abstraction		Y	Y	Y
3) Ploymorphism		Y	N	Y
4) Inheritance		Y	N	Y
			
		Partially     Object	  Pure OOPL
		OOPL	      based PL

















1) Encapsulation :
 It is a concept of hiding the data with the help of private variables.


2) Abstraction :
 Providing full information about an entity.


3) Polymorphism :
 It is a concept of writing more than one function with same name and with
 different arguments.


4) Inheritance :
 It is concept of deriving the features from one class into another class.



obs :
To work with OOPs, classes and objects are required.


Class :
 A class is a logical representation.
 

Object :
 Object is a physical representation.
	or 
 instance of a class.


> as per .Net class is a collection of Fields, Properties, Methods and Events.



Fields :
 Private data of a class is called as Fields.

Properties :
 Defines the look and feel of an object.

Methods :
 What an object can Do.

Events :
 What user can do with an object.



syntax to write a class >

 class <cl_name>
 {
  private int i,j;  // Fields
  private string s;

  public void print()  // Method/Function
  {


  }
 }


syntax to create an object >

 classname <obj_name>=new classname();
				|
			  Constructor

Note :
 Object can access only public data but not private data.


ex on classes and objects.



Note :
> The variables created with in a class are also called as instance variables.
> In C#.Net, by default every class will be inherited from System.Object class.


	System.Object 
		-> GethashCode()
		-> GetType()
		-> Equals()
		-> ToString()
	
	Test
	 -> Read()
	 -> Print()

> In C#.Net every class contains minimum 4 methods.






Working with methods and arguments >
syntax to Method:

 AccessSpecifier returnType methodName(args);

ex:>
 Public void Print(int x,int y)
 {

 }
 Public int Print(int x,int y)
 {
  return int_value;
 }





C#.Net allows to pass the parameters in 3 ways.

1) pass by value
2) pass by ref    // (ref int x) [Formal arguments]
3) pass by out


Note :

1) When formal args are modified and if modifications are REFLECTED on actual
 args then this concepts is called as Pass by ref.

2) When formal args are modified and if modifications are not REFLECTED on
 actual args then the concepts is called as Pass by value.

3) By default all the variables will be pass by value.

4) ref is a keyword, which is required while passing a variable by ref.

5) ref keyword must be used along with actual and formal args.

6) ref variables must be initialized before passing.




ex on Pass by value and ref 





Pass by out >

1) Out is a keyword.

2) Pass by out is 99% same as pass by ref.

3) In pass by out a variable can be passed without initialization also.

4) out=ref-initialization




ex on out







Working with this keyword :>

1) This is a keyword.
2) This works like an object for current class.
3) When instance and Local variables names are same then CLR gives
 importance for local.
4) In above case, in order to access instance variables this keyword
 is required.



ex on this keyword.





















Working with Polymorphism (Overloading) :>

 C#.Net supports Function Overloading and Operator Overloading.

Function Overloading :>

Function overloading is a concept of writing more than one function
 with same name and with different types of arguments.


Obs :
1) public void Add(){}
2) private void Add(){}
3) public int Add(){}
4) public void Add(int x){}
5) public void Add(int y){}
6) public void Add(ref int x){}
7) public void Add(out int x){}
8) public void add(){}









1&2 = 
1&3 = 
1&4 = 
2&4 = 
1&8 =
3&4 =
4&5 =
5&6 = 
6&7 =
7&5 =
 
















1&2 = Not Overlodable
1&3 = Not Overlodable
1&4 = Y
2&4 = y
3&4 = y
4&5 = N
5&6 = y
5&7 = y
6&7 = N
1&8 = N

ex on Function Overloading .






Working with 

Constructors					Destructors

					
C1)Cons is a special type of method, 	D1)Des is a special type of method, 									which
which will be executed automatically	will be executed automatically while 									an
while an object is about to create. 	object is about to delete.
					
C2)Cons name must be same as class	D2)Des name must be same as class 									name with 
name without Return Type.		a Tild(~) prefix and without return 									type
 syntax :				and access specifier.
 public cl_name()			 syntax :
 {					 ~cl_name()
					 {
 }			
					 }

C3)Cons are overlodable.		D3)Des are not overlodable.

C4)Cons will be used to initialize	D4)Des will be used to close the 									files and 
the variables or to open connections	connections or deallocating the 									memory.
and files etc.


Note :
 By default every class contains a default constructor.



ex on Cons and Des



Obs from ex :>
> In above ex., cons will be executed 3 times and des also executed
 3 times.
> When the project is closed, then des will be executed automatically
 after that with in two seconds Grabage Collector will be loaded.
> Garbage Collector Reclaims the entire memory allocated for the
 current project.
> Garbage collection will be done with the help of System.GC class.





Working with Static :>

1) Static is a keyword, which can be used along with fields, constructors,
 methods and classes.

Class Circle
{
 private int x,y,r;
 private static double pi=3.14;
 ...
 ...
 ...
}

2) Static var will be created only once after that static var are sharable
 by all the objects (Common Memory).

3) Instance variables will be created when object is loading into the memory.

4) Static variable will be created when class is loading into the memory,
 hence static var is also called as class var.

5) If static var is public, that it can be accessed directly with classname.

class Abc
{
 public int i; //instance var
 public static int s; //static var
}

Abc.s 	//valid
Abc.i	//Not valid

If x is an object then
x.i  //valid
x.s  //Not valid

6) Static cons will executed only once and which is used to access only
 static var.

ex 




Static methods and Static classes :>

1) Static method can access only static data.
2) Static method need to be call with the help of class name.
 	ex :> 	classname.Staticmethod()
3) When a class contains all static methods, then it is recommanded to
 declare the class as static.
4) Static classes are NOT allowed to creation of object.



ex >







Working with Operator Overloading:>

Obs:>
int i=10,j=20,k;	string S1="Abc",S2="xyz",S3;
k=i+j;    //30		S3=S1+S2;   //AbcXyz

If Test is a class and t1,t2 and t3 are objects then t3=t1+t2  //error 

1) +Operator is developed to use with no. and strings only hence t3=t1+t2 gives an
 error.
2) OOL is a concept of providing extended functionality for an existing operator.
3) All the operators are overdable except those contains a .(dot) i.e the following
 are not overdable.
4) While overloading Relational Operators these must be overloaded in PAIR.
to overload >,< must be overloaded.
to overload >=,<= must be overloaded.
to overload ==,!= must be overloaded.
5) Overloaded operator must be declared as Static.
6) Operator is keyword.
7) Syntax to overload an operator.
 public static returntype operator +(args)
 {
  logic;
 }


ex:>
A prog. to add the salaries of all the employees by overloading +.








Working with Inheritance :>
1) Inheritance is a concept of deriving the features from one class into another class.
2) Inheritance leads to code re-usability (write once use many times).
3) INH also saves memory.
4) Types in Inheritance.
	
	Single INH			Multilevel INH
	
	Base/Parent 			Base
	    |				  |
	Derived/Child 			Derived Base
					  |
					Derived

	


	Hirarchiral INH			Multiple INH  (Wrong)

		A			A		B

	B		C			C


Note:
* C#.Net does not supports multiple Inh directly, but a similar structure is possible
 with the help of interfaces.


Logical diagram on INH Concepts.


Modifier :
 These are the access specifiers for accessing.



Modifier   within the Class   Derived Class   Other Class   Derived Class  Other
							    of other	   Program
							    program


public		yes		yes		yes		yes	     yes

private		yes		No		No		No           No

protected	yes		yes		No		No           No

Internal	yes		yes		yes		No           No

Protected
 Internal	yes		yes		yes		yes          No












ex on protected data.
a company gives N Rs as Bonus when they are reaching the targets then calc total salary.




Working with Overriding (Run time polymorphism) :>
1) Overriding is a concept of having two methods with same name and same args in base
 and derived classes.
2) In Overriding, by default the priority will be given local class methods.
3) In above case, In order to call parent class methods "base" keyword is required.
4) "base" points to parent class and "this" keyword points to current class.


ex on base keyword with fields :>















Working with sealed classes :>
1) Sealed is a keyword.
2) Sealed classes are not inheritable.
3) When a class is providing full functionality, then recommanded to declare the
 class as sealed.



ex on Sealed Class :>














Working with Abstract classes and Interfaces :>
1) Abstract is a keyword.
2) Abstract keyword can be used with methods and 
Classes.
3) A method without body is called as Abstract Method.
4) Abstract methods are also called as Rules.
5) When a class contains atleast one abstract method,
then that class must be declared as abstract class.
6) syntax to write abstract method.
  public abstract void FindArea()
7) All Abstract methods must be overrided in Derived 
class.
 Syntax :
 public override void FindArea(){}
8) Abstract class provides a set of rules (Abstract 
methods), which must be followed (overrided) in derived
class.
9) Abstract classes are not Instantiatable, but a 
reference can be created.
If shape is an abstract base class and circle is a
derived class.
10) References works with the help of child class
memory.
	Shape x=new Cricle()



ex on Abstract CLass:>





Working with Interfaces :>
1) Interface are similar to abstract classes but 
interface contains only abstract methods.
2) syntax to write an interface
 interface inter_name
 {
  void Read();
  void Print();
 }

Note:
> All the interface methods are by default public
abstract.


syntax to use interface with classes :>

I		C1 		I1			I1	I2



C		C2		I2			    I3

class C:I      Class C2:C1      Interface I2:I1		Interface I3:I1,I2
{}	       {}		{}			{}




C1	C2		C1	I1			C1

	
	
    C3			    C2				I1
Not Supported		Class C2:C1,I1 {}		Not Supported
			Class C2:I1,C1 {} //Error
















