



OOPs Concepts (Object Oriented Programming Synopsis):>

OOPs based on the style of programming, the languages
 are divided into 3 types.

Procedural	Structured	OOPL
1960's ALGOL	1970's		1980's
No loops	BASIC		OOPs
No Arrays	COBOL		C++
No DMA		C



Problems with C lang. :>
1) 
 main()
 {
 int sal=40000;
 printf("%d",sal);
 }

output is ~ -7700
> There are no limits for the datatypes at runtime.



2) 
 main()
 {
 int i;
 i=500*500/500;
 printf("%d",i);
 }

output is -27
> There is no proper internal procedure for calculations.



3) 
 long sal=5000;
 main(){logic;}
 void Print(){logic;}
 void read(){logic;}
 void mktg()
 {
 long sal=500000;
 sal=sal+sal;
 }

No security for the data due to global variables.


> To overcome all these problems, ANSI defined a set of rules called as OOPs.
> When a lang. supports, the following OOPs concepts, then it is called as OOPL.

ex> C++, C#.Net, SmalkTalk, Java, VC++





OOPs concepts
			C++	VB6.0	Java/C#.Net
1) Encapsulation	Y	Y	Y
2) Abstraction		Y	Y	Y
3) Ploymorphism		Y	N	Y
4) Inheritance		Y	N	Y
			
		Partially     Object	  Pure OOPL
		OOPL	      based PL

























1) Encapsulation :
 It is a concept of hiding the data with the help of private variables.


2) Abstraction :
 Providing full information about an entity.


3) Polymorphism :
 It is a concept of writing more than one function with same name and with
 different types of arguments.


4) Inheritance :
 It is concept of deriving the features from one class into another class.



obs :
To work with OOPs, classes and objects are required.


Class :
 A class is a logical representation.
 

Object :
 Object is a physical representation.
	or 
 instance of a class.



> as per .Net class is a collection of Fields, Properties, Methods and Events.



Fields :
 Private data of a class is called as Fields.

Properties :
 Defines the look and feel of an object.

Methods :
 What an object can Do.

Events :
 What user can do with an object.



syntax to write a class >

 class <cl_name>
 {
  private int i,j;  // Fields 
  private string s;	//Instance var

  public void print()  // Method/Function
  {
	stmt();

  }
 }


syntax to create an object >

 classname <obj_name>=new classname();
				|
			 default Constructor

Note :
 Object can access only public data but not private data.


ex on classes and objects.



Note :
> The variables created with in a class are also called as instance variables.
> In C#.Net, by default every class will be inherited from System.Object class.


	System.Object 
		-> GethashCode()
		-> GetType()
		-> Equals()
		-> ToString()
	
	Test
	 -> Read()
	 -> Print()

> In C#.Net every class contains minimum 4 methods.






Working with methods and arguments >
syntax to Method:

 AccessSpecifier returnType methodName(args);

ex:>
 Public void Print(int x,int y)
 {

 }
 Public int Print(int x,int y)
 {
  return int_value;
 }























C#.Net allows to pass the parameters in 3 ways.

1) pass by value
2) pass by ref    // (ref int x) [Formal arguments]
3) pass by out


Note :

1) When formal args are modified and if modifications are REFLECTED on actual
 args then this concepts is called as Pass by ref.

2) When formal args are modified and if modifications are not REFLECTED on
 actual args then the concepts is called as Pass by value.

3) By default all the variables will be passed as pass by value.

4) ref is a keyword, which is required while passing a variable by ref.

5) ref keyword must be used along with actual and formal args.

6) ref variables must be initialized before passing.




ex on Pass by value and ref 












Pass by out >

1) Out is a keyword.

2) Pass by out is 99% same as pass by ref.

3) In pass by out a variable can be passed without initialization also.

4) out=ref-initialization




ex on out



















Working with this keyword :>

1) This is a keyword.
2) This works like an object for current class.
3) When instance and Local variables names are same then CLR gives
 importance for local.
4) In above case, in order to access instance variables this keyword
 is required.



ex on this keyword.








































Working with Polymorphism (Overloading) :>

 C#.Net supports Function Overloading and Operator Overloading.

Function Overloading :>

Function overloading is a concept of writing more than one function
 with same name and with different types of arguments and
 with different no. of arguments .


Obs :
1) public void Add(){}
2) private void Add(){}
3) public int Add(){}
4) public void Add(int x){}
5) public void Add(int y){}
6) public void Add(ref int x){}
7) public void Add(out int x){}
8) public void add(){}



1&2 = 
1&3 = 
1&4 = 
2&4 = 
1&8 =
3&4 =
4&5 =
5&6 = 
6&7 =
7&5 =
 









1&2 = Not Overlodable
1&3 = Not Overlodable
1&4 = Y
2&4 = y
3&4 = y
4&5 = N
5&6 = y
5&7 = y
6&7 = N
1&8 = N

ex on Function Overloading .






Working with 

Constructors					Destructors

					
C1)Cons is a special type of method, 	D1)Des is a special type of method, which
which will be executed automatically	will be executed automatically while an
while an object is about to create. 	object is about to delete.
					
C2)Cons name must be same as class	D2)Des name must be same as class name with 
name without Return Type.		a Tild(~) prefix and without return type
 syntax :				and access specifier.
 public cl_name()			 syntax :
 {					 ~cl_name()
					 {
 }			
					 }

C3)Cons are overlodable.		D3)Des are not overlodable.

C4)Cons will be used to initialize	D4)Des will be used to close the files and 
the variables or to open connections	connections or deallocating the memory.
and files etc.


Note :
 By default every class contains a default constructor.
	Test t=new Test();


ex on Cons and Des











Obs from ex :>
> In above ex., cons will be executed 3 times and des also executed
 3 times.
> When the project is closed, then des will be executed automatically
 after that with in two seconds Grabage Collector will be loaded.
> Garbage Collector Reclaims the entire memory allocated for the
 current project.
> Garbage collection will be done with the help of System.GC class.
























Working with Static :>

1) Static is a keyword, which can be used along with fields, constructors,
 methods and classes.

Class Circle
{
 private int x,y,r;
 private static double pi=3.14;
 ...
 ...
 ...
}

2) Static var will be created only once after that static var are sharable
 by all the objects (Common Memory).

3) Instance variables will be created when object is loading into the memory.

4) Static variable will be created when class is loading into the memory,
 hence static var is also called as class var.

5) If static var is public, that it can be accessed directly with classname.

class Abc
{
 public int i; //instance var
 public static int s; //static var
}

Abc.s 	//valid
Abc.i	//Not valid

If x is an object then
x.i  //valid
x.s  //Not valid

6) Static cons will executed only once and which is used to access only
 static var.

ex 




Static methods and Static classes :>

1) Static method can access only static data.
2) Static method need to be call with the help of class name.
 	ex :> 	classname.Staticmethod()
3) When a class contains all static methods, then it is recommanded to
 declare the class as static.
4) Static classes are NOT allowed to creation of object.



ex >





















Working with Operator Overloading:>

Obs:>
int i=10,j=20,k;	string S1="Abc",S2="xyz",S3;
k=i+j;    //30		S3=S1+S2;   //AbcXyz

If Test is a class and t1,t2 and t3 are objects then t3=t1+t2  //error 

1) +Operator is developed to use with no. and strings only hence t3=t1+t2 gives an
 error.
2) OOL is a concept of providing extended functionality for an existing operator.
3) All the operators are overdable except those contains a .(dot) i.e the following
 are not overdable.
4) While overloading Relational Operators these must be overloaded in PAIR.
to overload >,< must be overloaded.
to overload >=,<= must be overloaded.
to overload ==,!= must be overloaded.
5) Overloaded operator must be declared as Static.
6) Operator is keyword.
7) Syntax to overload an operator.
 public static returntype operator +(args)
 {
  logic;
 }


ex:>
A prog. to add the salaries of all the employees by overloading +.
























Working with Inheritance :>
1) Inheritance is a concept of deriving the features from one class into another class.
2) Inheritance leads to code re-usability (write once use many times).
3) INH also saves memory.
4) Types in Inheritance.
	
	Single INH			Multilevel INH
	
	Base/Parent 			Base
	    |				  |



	Derived/Child 			Derived Base
					  |



					Derived

	


	Hirarchiral INH			Multiple INH  (Wrong)

		A			A		B



	B		C			C


Note:
* C#.Net does not supports multiple Inh directly, but a similar structure is possible with the help of interfaces.


Logical diagram on INH Concepts.


Modifier :
 These are the access specifiers for accessing.



Modifier   within the Class   Derived Class   Other Class   Derived Class  Other
							    of other	   Program
							    program


public		yes		yes		yes		yes	     yes

private		yes		No		No		No           No

protected	yes		yes		No		No           No

Internal	yes		yes		yes		No           No

Protected
 Internal	yes		yes		yes		yes          No











ex on protected data.
a company gives N Rs as Bonus when they are reaching the targets then calc total
 salary.








Working with Overriding (Run time polymorphism) :>
1) Overriding is a concept of having two methods with same name and same
 args in base and derived classes.
2) In Overriding, by default the priority will be given local class methods.
3) In above case, In order to call parent class methods "base" keyword is required.
4) "base" points to parent class and "this" keyword points to current class.


ex on base keyword with fields :>
ex on Overrriding :>


























Working with sealed classes :>
1) Sealed is a keyword.
2) Sealed classes are not inheritable.
3) When a class is providing full functionality, then recommanded to declare the
 class as sealed.



ex on Sealed Class :>

























Working with Abstract classes and Interfaces :>
1) Abstract is a keyword.
2) Abstract keyword can be used with methods and 
Classes.
3) A method without body is called as Abstract Method.
4) Abstract methods are also called as Rules.
5) When a class contains atleast one abstract method,
then that class must be declared as abstract class.
6) syntax to write abstract method.
  public abstract void FindArea()
7) All Abstract methods must be overrided in Derived 
class.
 Syntax :
 public override void FindArea(){}
8) Abstract class provides a set of rules (Abstract 
methods), which must be followed (overrided) in derived
class.
9) Abstract classes are not Instantiatable, but a 
reference can be created.
If shape is an abstract base class and circle is a
derived class.
10) References works with the help of child class
memory.
	Shape x=new Cricle()



ex on Abstract CLass:>









Working with Interfaces :>
1) Interface are similar to abstract classes but 
interface contains only abstract methods.
2) syntax to write an interface
 interface inter_name
 {
  void Read();
  void Print();
 }

Note:
> All the interface methods are by default public
abstract.


syntax to use interface with classes :>

I		C1 		I1			I1	I2



C		C2		I2			    I3

class C:I      Class C2:C1      Interface I2:I1		Interface I3:I1,I2
{}	       {}		{}			{}




C1	C2		C1	I1			C1

	
	
    C3			    C2				I1
Not Supported		Class C2:C1,I1 {}		Not Supported
			Class C2:I1,C1 {} //Error



